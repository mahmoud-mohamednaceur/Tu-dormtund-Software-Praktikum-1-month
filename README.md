# SoPra Projekt 1 (Tu Dortmund Praktikum ,1 month Deadline ) 

In my **Software Praktikum** at TU Dortmund, we embarked on an exciting and intensive project that involved developing a complete **card game in Kotlin** with a fully functional **GUI interface**. Our task was to design and implement all the game functionalities within the span of the first month. This project provided a hands-on experience in structured software development, where I learned invaluable lessons about project planning, architecture, and the development process.

### Project Overview

The primary objective was to create a functional card game that included:
- A visually interactive GUI interface built in Kotlin, enhancing user engagement.
- Core gameplay mechanics that operated smoothly and met defined rules.
- A modular structure that separated logic from the UI, making it scalable and easier to maintain.

The initial phase required us to outline all the elements of the project, from **game rules** to **interface requirements** and **user interactions**. We focused on planning a solid structure, determining how each component would interact and which functionalities were essential for a smooth user experience.

### Key Learnings

#### 1. Importance of Project Structure and Planning
   - **Prioritizing Structure over Coding**: I discovered that coding should not be the first step in the process. Rather, the foundation lies in the **planning phase**, which involves deciding the project structure, breaking down requirements, and mapping out the entire project.
   - **Documentation**: Effective documentation is essential in large projects, especially for teamwork. It’s vital to have a clear vision of how different parts of the application connect. Early in the project, we documented game rules, user interactions, and the overall architecture.
   - **UML Diagrams**: Creating **UML diagrams** for classes, interactions, and workflows helped visualize the project and spot potential issues early on. This approach gave us a clear blueprint, ensuring that all parts of the project fit together seamlessly. It also made it easier to identify the roles and responsibilities of different classes and functions.

#### 2. Detailed Structural Design
   - **Class Design and Responsibility Assignment**: We defined each class and its responsibilities, ensuring a modular and organized codebase. This way, each class had a specific function, such as handling game logic, managing the GUI, or tracking player scores.
   - **Function Allocation**: I learned how crucial it is to think ahead about which functions will reside in which class. This planning saved us time and reduced confusion during development by giving us a well-thought-out roadmap for building the game.
   - **Separation of Logic and Interface**: We created a distinction between game logic and the GUI, making the project more modular and easier to troubleshoot or extend. This approach ensures that changes in one layer don’t ripple through the entire codebase, which is beneficial for long-term maintenance.

#### 3. Development Phase
   - **Coding Execution**: With a detailed plan and structure in place, coding became a more efficient and manageable process. Knowing precisely what each function should do and where it should go allowed us to focus on implementing each feature without confusion.
   - **Testing and Iteration**: The modular structure we had planned made it easier to test individual components and fix bugs. We could isolate issues to specific functions or classes, thanks to the organized setup from the planning phase.
   
### Conclusion

Overall, this project taught me that **coding is only a part of the development process**, and it often comes *second* to thorough planning and structuring. The initial phase—defining a solid structure, understanding each class’s role, and creating clear documentation—was invaluable in making the development phase smoother and more predictable. This experience reinforced the importance of a structured approach to software projects, where careful planning leads to more effective and efficient coding.
